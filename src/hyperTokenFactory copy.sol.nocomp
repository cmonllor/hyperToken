//SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { IERC20Metadata } from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import { IERC721 } from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import { IERC721Receiver } from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

import { ERC1967Proxy } from "../lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol";

import { WETH9 } from "@chainlink/contracts/src/v0.8/vendor/canonical-weth/WETH9.sol";

import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

import { RegistryModuleOwnerCustom } from "@chainlink/contracts-ccip/contracts/tokenAdminRegistry/RegistryModuleOwnerCustom.sol";
import { ITokenAdminRegistry } from "@chainlink/contracts-ccip/contracts/tokenAdminRegistry/TokenAdminRegistry.sol";
//import { RateLimiter } from "@chainlink/contracts-ccip/contracts/libraries/RateLimiter.sol";

import {IBurnMintERC20} from "@chainlink/contracts/src/v0.8/shared/token/ERC20/IBurnMintERC20.sol";

//import { LockReleaseTokenPool } from "./mods/LockReleaseTokenPool.sol";
//import { BurnMintTokenPool } from "./mods/BurnMintTokenPool.sol";
//import { TokenPool } from "./mods/TokenPool.sol";
import { MinimalBnMPool } from "./MinimalBnMPool.sol";

import { IHyperTokenFactory } from "./interfaces/IHyperTokenFactory.sol";
import { ICCHTTP_Consumer } from "./interfaces/ICCHTTP_Consumer.sol";
import { ICCHTTP_Peer } from "./interfaces/ICCHTTP_Peer.sol";

import { FeesManager } from "./FeesManager.sol";
import { HyperToken } from "./hyperToken.sol";
import { ERC20Backed_hyperToken } from "./ERC20Backed_hyperToken.sol";
import { NativeBacked_hyperToken } from "./nativeBacked_hyperToken.sol";
import { ERC721Backed_hyperToken } from "./ERC721Backed_hyperToken.sol";
import { hyperLINK } from "./hyperLINK.sol";
import { hyperLinkPool } from "./hyperLinkPool.sol";

import { HyperTokenManager } from "./hyperTokenManager.sol";

import { ICCHTTP_Peer } from "./CCHTTP_Peer.sol";
import { CCHTTP_Types } from "./CCHTTP_Types.sol";

contract HyperTokenFactory is IHyperTokenFactory, ICCHTTP_Consumer, FeesManager, Ownable {
    using SafeERC20 for IERC20;
    event HyperTokenStarted(address indexed hyperToken);
    event DeploymentSent(address indexed hyperToken, uint64 chainId);
    event DeploymentReceived(address indexed hyperToken, uint64 chainId);

    event HyperTokenDeployed(address indexed hyperToken);

    event Debug(string message);
    event DebugBytes(string message, bytes data);
    event NonRevertingError(string message, bytes data);

    uint64 public chainId;
    address public router;

    string public nativeName;
    string public nativeSymbol;
    uint8 public nativeDecimals;

    address public tokenAdminRegistry;
    address public regOwnerCustom;
    address public RMN;

    uint64 [] public enabledPeerChains;

    address public CCHTTP_peer;

    address public erc20Backed_hyperTokenImpl;
    address public nativeBacked_hyperTokenImpl;
    address public erc721Backed_hyperTokenImpl;

    struct deployment {
        uint64 chainId;
        uint256 chainSupply;
        bool waiting;
    }

    struct hyperTokenInfo {
        address hyperToken;
        string name;
        string symbol;
        uint8 decimals;
        CCHTTP_Types.HyperToken_Types tokenType; // Type of the hyper token (ERC20, ERC721, etc.)
        address backingToken;
        uint256 tokenId; // For ERC721, the token ID
        address pool;
        uint64 motherChainId;
        uint256 totalSupply; // Total supply across all chains
        deployment [] deployments;
        address tokenOwner;
    }

    struct deployHyperTokenParams {
        uint64 motherChainId;
        string name;
        string symbol;
        uint8 decimals;
        address backingToken;
        uint256 tokenId; // For ERC721, the token ID
        uint256 chainSupply;
        address tokenOwner;
        CCHTTP_Types.HyperToken_Types tokenType; // Type of the hyper token (ERC20, ERC721, etc.)
    }

    address public hyperNative;
    mapping (uint64 chain => address hyperNative) public peerChainHyperNative;

    constructor()  Ownable() { 
        transferOwnership(tx.origin);
    }

    function init(
        uint64 _chainId,
        address _router,
        address _linkToken,
        address _wrappedNative,
        string calldata _nativeName,
        string calldata _nativeSymbol,
        uint8 _nativeDecimals,
        address _tokenAdminRegistry,
        address _regOwnerCustom,
        address _RMN,
        address _CCHTTP_peer
        //HyperTokenManager _manager
    ) external onlyOwner {
        chainId = _chainId;
        router = _router;
        linkToken = _linkToken;

        wrappedNative = payable(_wrappedNative);
        nativeName = _nativeName;
        nativeSymbol = _nativeSymbol;
        nativeDecimals = _nativeDecimals;

        tokenAdminRegistry = _tokenAdminRegistry;
        regOwnerCustom = _regOwnerCustom;
        RMN = _RMN;
        
        CCHTTP_peer = _CCHTTP_peer;

        // Implementation contracts for hyper tokens
        // These contracts are used to deploy new hyper tokens
        // They are deployed once and then used to create proxies with CREATE2
        ERC20Backed_hyperToken hyperERC20_impl = new ERC20Backed_hyperToken(
            "",
            "",
            18
        );
        erc20Backed_hyperTokenImpl = address(hyperERC20_impl);

        NativeBacked_hyperToken hyperNative_impl = new NativeBacked_hyperToken(
            "",
            "",
            18
        );
        nativeBacked_hyperTokenImpl = address(hyperNative_impl);

        ERC721Backed_hyperToken hyperERC721_impl = new ERC721Backed_hyperToken(
            "",
            "",
            18
        );
        erc721Backed_hyperTokenImpl = address(hyperERC721_impl);
    }

    function enablePeerChain(uint64 _chainId) external onlyOwner {
        emit DebugBytes("enablePeerChain: enabling peer chain: ", abi.encodePacked(_chainId));
        // Check if the chain is already enabled
        for (uint256 i = 0; i < enabledPeerChains.length; i++) {
            if (enabledPeerChains[i] == _chainId) {
                revert("Chain already enabled");
            }
        }
        // Add the chain to the list of enabled peer chains
        enabledPeerChains.push(_chainId);
    }



    function deployHyperLINK() external onlyOwner {
        emit Debug("deployHyperLINK: deploying hyperLINK token");
        bytes32 hyperLinkSalt = keccak256(abi.encodePacked(
            "hyperLINK", // Name of the token
            "hLINK", // Symbol of the token
            uint8(18) // Decimals of the token
        ));
        hyperLINK hyperLinkCtr = new hyperLINK{ salt: hyperLinkSalt }( );
        hyperLinkToken = address(hyperLinkCtr);
        emit Debug("deployHyperLINK: hyperLINK created");
        emit DebugBytes("deployHyperLINK: hyperLinkToken: ", abi.encodePacked(hyperLinkToken));


        hyperLinkCtr.init(
            chainId, // Set the mother chain ID
            linkToken // Set the link token address
        );

        bytes32 hyperLinkPoolSalt = keccak256(abi.encodePacked(
            "hyperLinkPool", // Name of the pool
            hyperLinkToken,
            uint8(18) // Decimals of the pool
        ));
        emit DebugBytes("deployHyperLINK: hyperLinkPoolSalt: ", abi.encodePacked(hyperLinkPoolSalt));
        hyperLinkPool linkPool = new hyperLinkPool{ salt: hyperLinkPoolSalt }(
            hyperLinkToken // Hyperlink token address
        );
        linkPool.init(
            linkToken
        );
        emit Debug("deployHyperLINK: hyperLinkPool created");
        emit DebugBytes("deployHyperLINK: hyperLinkPool: ", abi.encodePacked(address(linkPool)));


        hyperTokens[hyperLinkToken].hyperToken = hyperLinkToken; // Set the hyperLINK token address
        hyperTokens[hyperLinkToken].name = "hyperLINK"; // Set the name of the token
        hyperTokens[hyperLinkToken].symbol = "hLINK"; // Set the symbol of the token
        hyperTokens[hyperLinkToken].decimals = 18; // Set the decimals of the token
        hyperTokens[hyperLinkToken].tokenType = CCHTTP_Types.HyperToken_Types.HyperERC20; // Set the type of the hyper token
        hyperTokens[hyperLinkToken].backingToken = linkToken; // Set the backing token address
        hyperTokens[hyperLinkToken].tokenId = 0; // For ERC20, tokenId is not used
        hyperTokens[hyperLinkToken].motherChainId = chainId; // Set the mother chain ID to the current chain ID
        hyperTokens[hyperLinkToken].tokenOwner = msg.sender; // Set the token owner to the contract deployer
        hyperTokens[hyperLinkToken].totalSupply = 0; // Not tracked in hyperLinkToken

        deployCCIP_Pool(
            hyperLinkToken, // HyperToken address
            0, // motherChain: 0 so all hyperLINK CCIP_pools share address in all EVM chains
            18 // Decimals of the token
        );

        hyperLinkCtr.setLinkPool(address(linkPool)); // Set the link pool address in the hyperLINK contract      

        // Register the hyperLINK token in the TokenAdminRegistry
        registerHyperToken(hyperLinkToken);
        hyperLinkToken = hyperLinkToken; // Set the hyperLINK token address
    }


    function deployHyperNative() external onlyOwner {
        emit DebugBytes("deployHyperNative: deploying hyperNative token", abi.encodePacked(msg.sender));
        emit DebugBytes("deployHyperNative: factory owner: ", abi.encodePacked(owner()));
        string memory hN_name = string( abi.encodePacked("hyper_", nativeName ) );
        string memory hN_symbol = string( abi.encodePacked("h", nativeSymbol ) );
        _deployHyperNative(
            chainId, // Set the mother chain ID
            hN_name, // Set the name of the token
            hN_symbol, // Set the symbol of the token
            nativeDecimals, // Set the decimals of the token
            wrappedNative, // Wrapped native token address
            msg.sender // Token owner is the contract deployer
        );
        //prepare a deployment for each peer chain
        for (uint256 i = 0; i < enabledPeerChains.length; i++) {
            uint64 chain = enabledPeerChains[i];
            // Create a deployment for each enabled peer chain
            deployment memory deploymentInfo;
            deploymentInfo.chainId = chain; // Set the chain ID for the deployment
            deploymentInfo.chainSupply = 0; // Initially set to 0, will be updated later
            deploymentInfo.waiting = false; // Initially not waiting for confirmation
            hyperTokens[hyperNative].deployments.push(deploymentInfo);
            emit DebugBytes("deployHyperNative: added deployment for peer chain: ", abi.encodePacked(chain));
        }
        emit Debug("deployHyperNative: hyperNative deployed");
    }


    function _deployHyperNative(
        uint64 motherChain,
        string memory name,
        string memory symbol,
        uint8 decimals,
        address backing,  
        address tokenOwner              
    ) internal  {

        require(nativeBacked_hyperTokenImpl != address(0), "Implementation not set");

        bytes32 salt = _hyperTokenSalt(name, symbol, decimals);

        // Prepare empty init data (will call init after deployment)
        bytes memory initData = "";

        bytes memory bytecode = abi.encodePacked(
            type(ERC1967Proxy).creationCode,
            abi.encode(nativeBacked_hyperTokenImpl, initData)
        );

        address proxyAddr;
        assembly {
            proxyAddr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)
            if iszero(proxyAddr) { revert(0, 0) }
        }

        emit Debug("createNativeBacked_hyperToken: ERC1967Proxy created");
        emit DebugBytes("createNative_hyperToken: hyperTokenAdd: ", abi.encodePacked(proxyAddr));
    
        // Create a NativeBacked_hyperToken instance
        NativeBacked_hyperToken hyperNativeCtr = NativeBacked_hyperToken(proxyAddr);

        hyperNativeCtr.init(
            motherChain==chainId ? 0 : motherChain, // Set the mother chain ID to 0 for native tokens in mother chain
            // mother chain ID: 0 for native tokens in mother chain
            name, // Set the name of the token
            symbol, // Set the symbol of the token
            decimals, // Set the decimals of the token
            backing, // Set the backing token address
            address(0), // Pool address will be set later
            wrappedNative, // Wrapped native token address
            linkToken, // Link token address
            hyperLinkToken // Hyperlink token address
        );

        emit Debug("deployHyperNative: NativeBacked_hyperToken initialized");

        hyperTokens[address(hyperNativeCtr)].hyperToken = address(hyperNativeCtr); // Set the hyperNative token address
        hyperTokens[address(hyperNativeCtr)].name = name; // Set the name of the token
        hyperTokens[address(hyperNativeCtr)].symbol = symbol; // Set the symbol of the token
        hyperTokens[address(hyperNativeCtr)].decimals = decimals; // Set the decimals of the token
        hyperTokens[address(hyperNativeCtr)].tokenType = CCHTTP_Types.HyperToken_Types.HyperNative; // Set the type of the hyper token
        hyperTokens[address(hyperNativeCtr)].backingToken = backing; // Set the backing token address
        hyperTokens[address(hyperNativeCtr)].tokenId = 0; // For native, tokenId is not used
        hyperTokens[address(hyperNativeCtr)].motherChainId = motherChain; // Set the mother chain ID to the current chain ID
        hyperTokens[address(hyperNativeCtr)].tokenOwner = msg.sender; // Set the token owner to the contract deployer
        hyperTokens[address(hyperNativeCtr)].totalSupply = 0; // Initialy no native supply
        
        if( motherChain == chainId ) {
            hyperNative = address(hyperNativeCtr); // Set the hyperNative token address
        } else {
            peerChainHyperNative[motherChain] = address(hyperNativeCtr); // Set the hyperNative token address for the peer chain
        }
        deployCCIP_Pool(
            address(hyperNativeCtr), // HyperToken address
            motherChain, // Mother chain ID
            nativeDecimals // Decimals of the token
        );
        emit Debug("deployHyperNative: CCIP_Pool deployed for hyperNative");
              
    }

    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4) {
        // This function is called when the contract receives an ERC721 token
        // We can use this to set the backing NFT if it wasn't set in the constructor
        emit Debug("onERC721Received: ERC721 token received");        
        return IERC721Receiver.onERC721Received.selector;
    }


    function startHyperToken(
        string calldata _name,
        string calldata _symbol,
        uint8 _decimals,
        address _backingToken,
        uint256 tokenId,   
        uint256 _chainSupply,
        CCHTTP_Types.HyperToken_Types tokenType
    ) public payable returns (address) {
        require(
            _backingToken != wrappedNative,
            "hyperNative deploy reserved to protocol owner"
        );
        require(
            _backingToken != linkToken,
            "hyperLink deploy reserved to protocol owner"
        );

        if( tokenType == CCHTTP_Types.HyperToken_Types.HyperERC20 ) {
            require( ERC20Backed_hyperTokens[_backingToken] == address(0), "HyperToken already exists for this backing token" );
            require( IERC20(_backingToken).balanceOf(msg.sender) >= _chainSupply, "Insufficient balance of backing token" );
            require( IERC20(_backingToken).allowance(msg.sender, address(this)) >= _chainSupply, "Insufficient allowance for backing token" );
        } else if (tokenType == CCHTTP_Types.HyperToken_Types.HyperERC721) {
            require(IERC721(_backingToken).ownerOf(tokenId) == msg.sender, "You do not own the ERC721 token");
            require(IERC721(_backingToken).getApproved(tokenId) == address(this) 
                || IERC721(_backingToken).isApprovedForAll(msg.sender, address(this)), 
                "Not approved to transfer the ERC721 token"
            );
        } else if (tokenType == CCHTTP_Types.HyperToken_Types.HyperNative) {
            // User can send native or WETH as backing token
            revert("HyperNative tokens cannot be started with this function, use deployHyperNative instead");
        } else {
            revert("Unknown token type");
        }
        
        address hyperTokenAdd;
        if( tokenType == CCHTTP_Types.HyperToken_Types.HyperERC721 ) { 
            hyperTokenAdd = estimateHyperERC721Address(
                _name, // Name of the token
                _symbol, // Symbol of the token
                _decimals, // Decimals of the token
                _backingToken, // Backing token address (ERC721 contract)
                tokenId // Token ID for the ERC721 token
            );
        }
        else{
                hyperTokenAdd = estimateTokenAddress(
                _name, // Name of the token
                _symbol, // Symbol of the token
                _decimals // Decimals of the token
            );
        }
        emit DebugBytes("startHyperToken: estimated address: ", abi.encode(hyperTokenAdd));
        address expectedPoolAddress = estimatePoolAddress(
            hyperTokenAdd, // HyperToken address
            chainId, // Mother chain ID
            _decimals // Decimals of the token
        );
        
        // Set the properties of the hyperToken
        hyperTokens[hyperTokenAdd].hyperToken = hyperTokenAdd;
        hyperTokens[hyperTokenAdd].name = _name;
        hyperTokens[hyperTokenAdd].symbol = _symbol;
        hyperTokens[hyperTokenAdd].decimals = _decimals;
        hyperTokens[hyperTokenAdd].backingToken = _backingToken;
        hyperTokens[hyperTokenAdd].tokenId = tokenId;
        hyperTokens[hyperTokenAdd].tokenType = tokenType; // Set the type of the hyper token
        hyperTokens[hyperTokenAdd].pool = expectedPoolAddress; // Set the pool address
        hyperTokens[hyperTokenAdd].motherChainId = chainId; // Set the mother chain ID to the current chain ID
        hyperTokens[hyperTokenAdd].tokenOwner = msg.sender;
        hyperTokens[hyperTokenAdd].totalSupply = _chainSupply; // Set the total supply for the hyper token

        // Register the hyper token in the ERC20Backed_hyperTokens mapping
        ERC20Backed_hyperTokens[_backingToken] = hyperTokenAdd;

        
        
        // Transfer the backing token to this contract
        if( tokenType == CCHTTP_Types.HyperToken_Types.HyperERC20 ) {
            IERC20(_backingToken).safeTransferFrom(
                msg.sender,
                address(this), 
                _chainSupply
            ); 
        }
        else if( tokenType == CCHTTP_Types.HyperToken_Types.HyperERC721 ) {
            // For ERC721, transfer the token to this contract
            IERC721(_backingToken).safeTransferFrom(
                msg.sender,
                address(this), 
                tokenId
            );
        }
        else if (tokenType == CCHTTP_Types.HyperToken_Types.HyperNative) {
            if( msg.value > 0 ){ //user sent in native
                IERC20(wrappedNative).safeTransferFrom(
                    msg.sender,
                    address(this), 
                    msg.value
                ); // Transfer the wrapped native token to this contract
            }
            else{
                IERC20(wrappedNative).safeTransferFrom(
                    msg.sender,
                    address(this), 
                    _chainSupply
                ); // Transfer the wrapped native token to this contract
            }
        }

        deployment memory initialDeployment; //in this chain
        initialDeployment.chainId = chainId; // Set the chain ID for the deployment
        initialDeployment.chainSupply = _chainSupply; // Set the chain supply for the deployment
        initialDeployment.waiting = false; // Initially waiting for confirmation
        hyperTokens[hyperTokenAdd].deployments.push(initialDeployment);
        emit Debug("startHyperToken: HyperToken deployment initialized in  mother chain");

        //prepare a deployment for each peer chain
        for (uint256 i = 0; i < enabledPeerChains.length; i++) {
            uint64 chain = enabledPeerChains[i];
            // Create a deployment for each enabled peer chain
            deployment memory deploymentInfo;
            deploymentInfo.chainId = chain; // Set the chain ID for the deployment
            deploymentInfo.chainSupply = 0; // Initially set to 0, will be updated later
            deploymentInfo.waiting = true; // Initially not waiting for confirmation
            hyperTokens[hyperTokenAdd].deployments.push(deploymentInfo);
            emit DebugBytes("startHyperToken: added deployment for peer chain: ", abi.encodePacked(chain));
        }
        // Emit an event to indicate that the HyperToken has been started
        emit HyperTokenStarted(hyperTokenAdd);
        return hyperTokenAdd;
    }


    // Helper to compute the salt
    function _hyperTokenSalt(
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_name, _symbol, _decimals));
    }

    // Deploy the proxy using CREATE2 with deterministic address
    function createERC20Backed_hyperToken(
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) internal returns (address) {
        require(erc20Backed_hyperTokenImpl != address(0), "Implementation not set");

        bytes32 salt = _hyperTokenSalt(_name, _symbol, _decimals);

        // Prepare empty init data (will call init after deployment)
        bytes memory initData = "";

        bytes memory bytecode = abi.encodePacked(
            type(ERC1967Proxy).creationCode,
            abi.encode(erc20Backed_hyperTokenImpl, initData)
        );

        address proxyAddr;
        assembly {
            proxyAddr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)
            if iszero(proxyAddr) { revert(0, 0) }
        }

        emit Debug("createERC20Backed_hyperToken: ERC1967Proxy created");
        emit DebugBytes("createERC20Backed_hyperToken: hyperTokenAdd: ", abi.encodePacked(proxyAddr));
        return proxyAddr;
    }


    function _hyperERC721Salt(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        address _backingToken,
        uint256 tokenId
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_name, _symbol, _decimals, _backingToken, tokenId));
    }


    // Deploy the proxy using CREATE2 with deterministic address
    function createERC721Backed_hyperToken(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        address backingToken,
        uint256 tokenId
    ) internal returns (address) {
        require(erc20Backed_hyperTokenImpl != address(0), "Implementation not set");

        bytes32 salt = _hyperERC721Salt(_name, _symbol, _decimals, backingToken, tokenId);

        // Prepare empty init data (will call init after deployment)
        bytes memory initData = "";

        bytes memory bytecode = abi.encodePacked(
            type(ERC1967Proxy).creationCode,
            abi.encode(erc721Backed_hyperTokenImpl, initData)
        );

        address proxyAddr;
        assembly {
            proxyAddr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)
            if iszero(proxyAddr) { revert(0, 0) }
        }

        emit Debug("createERC721Backed_hyperToken: ERC1967Proxy created");
        emit DebugBytes("createERC721Backed_hyperToken: hyperTokenAdd: ", abi.encodePacked(proxyAddr));
        return proxyAddr;
    }



    function deployHyperToken(
        deployHyperTokenParams memory params
    ) internal returns (address) {
        address hyperTokenAdd;
        uint64 motherChainInToken = params.motherChainId;
        if(params.motherChainId == chainId){
            motherChainInToken = 0; //mother chain is 0 for hyperTokens in motherchain
        }
        
        if( params.tokenType == CCHTTP_Types.HyperToken_Types.HyperERC20 ) {
            // Create a  ERC20Backed_hyperToken instance
            hyperTokenAdd = createERC20Backed_hyperToken(
                params.name, // Name of the token
                params.symbol, // Symbol of the token
                params.decimals // Decimals of the token
            );
            ERC20Backed_hyperToken(hyperTokenAdd).init(
                motherChainInToken, // Set the mother chain ID
                params.name,
                params.symbol,
                params.decimals,
                params.backingToken, // Set the backing token address
                hyperTokens[hyperTokenAdd].pool, // Set the pool address
                wrappedNative, // Wrapped native token address
                linkToken, // Link token address
                hyperLinkToken // Hyperlink token address
            );
        }
        else if( params.tokenType == CCHTTP_Types.HyperToken_Types.HyperERC721 ) {
            // Create a  ERC721Backed_hyperToken instance
            hyperTokenAdd = createERC721Backed_hyperToken(
                params.name, // Name of the token
                params.symbol, // Symbol of the token
                params.decimals, // Decimals of the token
                params.backingToken, // Backing token address (ERC721 contract)
                params.tokenId // Token ID for the ERC721 token
            );
            ERC721Backed_hyperToken(hyperTokenAdd).init(
                motherChainInToken, // Set the mother chain ID
                params.name,
                params.symbol,
                params.decimals,
                params.backingToken, // Set the backing token address
                params.tokenId, // Set the token ID for the ERC721 token
                hyperTokens[hyperTokenAdd].pool, // Set the pool address
                wrappedNative, // Wrapped native token address
                linkToken, // Link token address
                hyperLinkToken // Hyperlink token address
            );


        } else {
            revert("Unknown token type");
        }

        

        emit Debug("deployHyperToken: ERC20Backed_hyperToken created");
        emit DebugBytes("deployHyperToken: hyperTokenAdd: ", abi.encodePacked(hyperTokenAdd));
       
        
        if( params.motherChainId != chainId) { //child: register data
            emit Debug("deployHyperToken: registering child hyperToken");                
            hyperTokens[hyperTokenAdd].hyperToken = hyperTokenAdd;
            hyperTokens[hyperTokenAdd].name = params.name;
            hyperTokens[hyperTokenAdd].symbol = params.symbol;
            hyperTokens[hyperTokenAdd].decimals = params.decimals;
            hyperTokens[hyperTokenAdd].backingToken = params.backingToken;
            hyperTokens[hyperTokenAdd].tokenId = params.tokenId; // For ERC20, tokenId is not used
            hyperTokens[hyperTokenAdd].tokenType = params.tokenType; // Set the type of the hyper token
            hyperTokens[hyperTokenAdd].motherChainId = params.motherChainId;
            hyperTokens[hyperTokenAdd].tokenOwner = params.tokenOwner;
            
            /* we dont register in child chains
            hyperTokens[hyperTokenAdd].deployments.push(
                deployment({
                    chainId: params.motherChainId,
                    chainSupply: params.chainSupply,
                    waiting: false, // Initially not waiting for confirmation
                })
            );
            */
        }
        else{   //else mother, already registered
            emit Debug("deployHyperToken: registering mother hyperToken");
            hyperTokens[hyperTokenAdd].deployments[0].waiting = false; //not waiting for confirmation
            if(params.tokenType == CCHTTP_Types.HyperToken_Types.HyperERC20) {
                //transfer backing supply to token contract
                IERC20(params.backingToken).safeTransfer(
                    hyperTokenAdd, //backing token is held by token contract
                    hyperTokens[hyperTokenAdd].totalSupply
                ); // Transfer the backing token to this contract
            }
            else if(params.tokenType == CCHTTP_Types.HyperToken_Types.HyperERC721) {
                //transfer backing NFT to token contract
                IERC721(params.backingToken).safeTransferFrom(
                    address(this), // Transfer from this contract
                    hyperTokenAdd, //backing token is held by token contract
                    params.tokenId //token ID for the ERC721 token
                );
            }
        }
        //deploy pool
        deployCCIP_Pool(
            hyperTokenAdd, // HyperToken address
            params.motherChainId, // Mother chain ID
            params.decimals // Decimals of the token
        );

        uint256 userSupply = params.motherChainId == chainId ? 
            hyperTokens[hyperTokenAdd].deployments[0].chainSupply : params.chainSupply;

        //mint the initial supply 
        HyperToken(hyperTokenAdd).mint(
            params.tokenOwner,
            userSupply 
        );
        if(params.tokenType == CCHTTP_Types.HyperToken_Types.HyperERC20) { 
            // Register the hyper token in the ERC20Backed_hyperTokens mapping
            ERC20Backed_hyperTokens[params.backingToken] = hyperTokenAdd;
        }
        // Register the hyper token in the TokenAdminRegistry
        registerHyperToken(hyperTokenAdd);

        emit HyperTokenDeployed(hyperTokenAdd);

        return hyperTokenAdd;
    }


    function deployCCIP_Pool(
        address hyperTokenAdd,
        uint64 motherChainId,
        uint8 decimals
    ) internal {  //Scope to avoid stack too deep error
        // Create a MinimalBnMPool instance
        bytes32 poolSalt = keccak256(
            abi.encodePacked(hyperTokenAdd, motherChainId, decimals)
        );
        emit DebugBytes("deployHyperToken: poolSalt: ", abi.encodePacked(poolSalt));
        emit DebugBytes("deployHyperToken: hyperTokenAdd: ", abi.encodePacked(hyperTokenAdd));
        emit DebugBytes("deployHyperToken: params.motherChainId: ", abi.encodePacked(motherChainId));
        emit DebugBytes("deployHyperToken: params.decimals: ", abi.encodePacked(decimals));
        MinimalBnMPool pool = new MinimalBnMPool{ salt: poolSalt }(
            hyperTokenAdd
        );
        emit DebugBytes("deployHyperToken: MinimalBnMPool created: ", abi.encodePacked(address(pool)));

        pool.init(
            router, // Router address
            RMN // RMN address
        );
        HyperToken(hyperTokenAdd).setPool(address(pool));
        address realPoolAddress = HyperToken(hyperTokenAdd).getPool();
        emit DebugBytes("deployHyperToken: pool address set in hyperToken: ", abi.encodePacked(realPoolAddress));

        // Enable the remote chains in the pool
        emit Debug("deployHyperToken: enabling remote chains in the pool");


        emit DebugBytes("deployHyperToken: number of enabled peer chains: ", abi.encodePacked(enabledPeerChains.length));
        for (uint256 i = 0; i < enabledPeerChains.length; i++) {
            emit DebugBytes("deployHyperToken: enabling remote chain: ", abi.encodePacked(enabledPeerChains[i]));
            uint64 chain = enabledPeerChains[i];
            // Set the onRamp and offRamp addresses for the remote chain
            pool.enableRemoteChain(chain);
        }
        hyperTokens[hyperTokenAdd].pool = address(pool); // Set the pool address in the hyperTokens mapping
    }
    
    function estimatePoolAddress(
        address hyperToken,
        uint64 motherChain,
        uint8 decimals
    ) internal view returns (address) {
        // Estimate the pool address based on the hyper token address, mother chain, and decimals
        bytes32 poolSalt = keccak256(abi.encodePacked(hyperToken, motherChain, decimals));
        
        bytes memory bytecode = abi.encodePacked(
            type(MinimalBnMPool).creationCode, 
            uint(uint160(hyperToken))
        );
        address poolAddress = address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            address(this),
            poolSalt,
            //keccak256(type(BurnMintTokenPool).creationCode)
            keccak256(bytecode)
        )))));
        return poolAddress;
    }


    // Deterministic address calculation for the proxy
    function estimateTokenAddress(
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) internal view returns (address) {
        bytes32 salt = _hyperTokenSalt(_name, _symbol, _decimals);
        bytes memory bytecode = abi.encodePacked(
            type(ERC1967Proxy).creationCode,
            abi.encode(erc20Backed_hyperTokenImpl, "")
        );
        bytes32 hash = keccak256(bytecode);
        return address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            address(this),
            salt,
            hash
        )))));
    }

    function estimateHyperERC721Address(
        string memory _name,
        string memory _symbol,
        uint8 _decimals,
        address _backingToken,
        uint256 tokenId
    ) internal view returns (address) {
        bytes32 salt = _hyperERC721Salt(_name, _symbol, _decimals, _backingToken, tokenId);
        bytes memory bytecode = abi.encodePacked(
            type(ERC1967Proxy).creationCode,
            abi.encode(erc721Backed_hyperTokenImpl, "")
        );
        bytes32 hash = keccak256(bytecode);
        return address(uint160(uint256(keccak256(abi.encodePacked(
            bytes1(0xff),
            address(this),
            salt,
            hash
        )))));
    }

    function registerHyperToken(address hyperToken) internal{
        emit DebugBytes("registerHyperToken: hyperToken: ", abi.encodePacked(hyperToken));
        //begin regiser
        RegistryModuleOwnerCustom regMod = RegistryModuleOwnerCustom(regOwnerCustom);
        regMod.registerAdminViaGetCCIPAdmin(hyperToken);
        //Accept admin role
        ITokenAdminRegistry reg = ITokenAdminRegistry(tokenAdminRegistry); 
        reg.acceptAdminRole(hyperToken);

        // Set the pool for the hyper token
        reg.setPool(hyperToken, hyperTokens[hyperToken].pool);
    }

    function sendDeploymentToChain(
        address hyperToken,
        uint64 destChainId,
        uint256 _chainSupply,
        address feeToken,
        uint256 feeAmount,
        address CCIP_ackToken,
        uint256 CCIP_ackAmount
    ) public {
        emit Debug("sendDeploymentToChain called");
        
        require(destChainId != chainId, "Cannot deploy to the same chain");
        hyperTokenInfo storage info = hyperTokens[hyperToken];
        require(info.hyperToken != address(0), "HyperToken does not exist");
        require(msg.sender == info.tokenOwner, "Only the token owner can send deployment");

        // Check if the hyperToken is already deployed on the destination chain
        for (uint256 i = 0; i < info.deployments.length; i++) {
            if (info.deployments[i].chainId == destChainId) {
                emit DebugBytes("sendDeploymentToChain: found existing deployment on chain: ", abi.encodePacked(destChainId));                
                info.deployments[i].chainSupply = _chainSupply; // Update the chain supply for this deployment
                break; // Exit the loop if the chain is found   
            }
        }
        if( hyperTokens[hyperToken].tokenType == CCHTTP_Types.HyperToken_Types.HyperERC20 ) {
            IERC20(info.backingToken).safeTransferFrom(
                msg.sender,
                address(this), //backing token is held by factory contract until hyperToken is deployed
                _chainSupply
            ); // Transfer the backing token to this contract
            //upgrade totalSupply
            hyperTokens[hyperToken].totalSupply += _chainSupply; // Decrease the total supply for the hyper token
        } else if (info.tokenType == CCHTTP_Types.HyperToken_Types.HyperERC721) {
            //transfer already done in motherchain, if it's child, don't needed
            //just upgrade totalSupply
            emit Debug("sendDeploymentToChain: HyperERC721 token type detected");
            hyperTokens[hyperToken].totalSupply += _chainSupply; // Decrease the total supply for the hyper token
        } else if (info.tokenType == CCHTTP_Types.HyperToken_Types.HyperNative) {
            //native is deployed by developer team
            //users will wrap and that will update supply
            //no upgrade in totalSupply to do
            emit Debug("sendDeploymentToChain: HyperNative token type detected");
        } else {
              revert("Unknown token type");
        }


        uint chainIdx = 0;
        // Check if chain is enabled
        for(uint256 i = 0; i < enabledPeerChains.length; i++) {
            if (enabledPeerChains[i] == destChainId) {
                // Chain is enabled
                chainIdx = i; // Store the index of the enabled chain
                break;
            }
            if (i == enabledPeerChains.length - 1) {
                revert("Chain not enabled");
            }
        }
        emit DebugBytes("sendDeploymentToChain: chainIdx: ", abi.encodePacked(chainIdx));
        emit DebugBytes("sendDeploymentToChain: destChainId: ", abi.encodePacked(destChainId));
        emit DebugBytes("sendDeploymentToChain: hyperToken: ", abi.encodePacked(hyperToken));

        // Get the deployment info
        deployment storage dep;
        uint depIdx;
        for(uint256 i = 0; i < info.deployments.length; i++) {
            if (info.deployments[i].chainId == destChainId) {
                dep = info.deployments[i]; // Get the deployment info for the destination chain
                depIdx = i; // Store the index of the deployment
                break;
            }
        }
        dep = info.deployments[depIdx]; // Get the deployment info for the destination chain
        emit Debug("sendDeploymentToChain: deployment info found");
        emit DebugBytes("sendDeploymentToChain: depIdx:", abi.encodePacked(depIdx));

        dep.chainId = destChainId; // Set the chain ID for the deployment
        dep.chainSupply = _chainSupply; // Set the chain supply for the deployment
        dep.waiting = true; // Now we are waiting for confirmation
        
        emit Debug("sendDeploymentToChain: deployment info updated");
        emit DebugBytes("sendDeploymentToChain: dep.chainId: ", abi.encodePacked(dep.chainId));
        emit DebugBytes("sendDeploymentToChain: dep.chainSupply: ", abi.encodePacked(dep.chainSupply));
        emit DebugBytes("sendDeploymentToChain: dep.waiting: ", abi.encodePacked(dep.waiting));
        
        //update CrossChain Supply
        hyperTokens[hyperToken].totalSupply += _chainSupply;

        // Send the deployment to the specified chain
        //TODO: Implement the logic to send the deployment to the specified chain
        CCHTTP_Types.deployAndMintParams memory params = CCHTTP_Types.deployAndMintParams({
            chainId: destChainId,
            origin: address(this),
            destination: address(this), //EVM predictable address
            linkToken: linkToken,
            linkAmount: CCIP_ackAmount,
            feeToken: feeToken,
            feesAmount: feeAmount,
            name_length: uint8(bytes(info.name).length),
            name: info.name,
            symbol_length: uint8(bytes(info.symbol).length),
            symbol: info.symbol,
            decimals: info.decimals,
            deployer: info.tokenOwner,
            chainSupply: dep.chainSupply,
            expectedTokenAddress: hyperToken,
            tokenType: info.tokenType,
            backingToken: info.backingToken,
            tokenId: info.tokenId
        });

        cashInAndApproveFeesAndACK(
            feeToken,
            feeAmount,
            CCIP_ackToken,
            CCIP_ackAmount,
            CCHTTP_peer
        );

        ICCHTTP_Peer(CCHTTP_peer).deployAndMintRequest(
            params
        );
        
        // Emit an event to indicate that the deployment has been sent
        emit DeploymentSent(hyperToken, chainId);
    }



    function estimateDeploymentCost(
        address hyperToken,
        uint64 destChainId,
        address feeToken,
        address CCIP_ackToken
    ) public /*view*/ returns (uint256 feeAmount, uint256 ackAmount) {
        uint256 chainIdx = 0;
        // Check if the chain is enabled
        for (uint256 i = 0; i < enabledPeerChains.length; i++) {
            if (enabledPeerChains[i] == destChainId) {
                // Chain is enabled
                chainIdx = i; // Store the index of the enabled chain
                break;
            }
            if (i == enabledPeerChains.length - 1) {
                revert("Chain not enabled");
            }
        }

        uint256 nDeployments = hyperTokens[hyperToken].deployments.length;
        emit DebugBytes("estimateDeploymentCost: number of deployments: ", abi.encodePacked(nDeployments));

        CCHTTP_Types.deployAndMintParams memory params = CCHTTP_Types.deployAndMintParams({
            chainId: destChainId,
            origin: address(this),
            destination: address(this), // Assuming the destination is this contract
            linkToken: linkToken,
            linkAmount: 0, // This will be estimated later
            feeToken: feeToken,
            feesAmount: 0, // This will be estimated later
            name_length: uint8(bytes(hyperTokens[hyperToken].name).length),
            name: hyperTokens[hyperToken].name,
            symbol_length: uint8(bytes(hyperTokens[hyperToken].symbol).length),
            symbol: hyperTokens[hyperToken].symbol,
            decimals: hyperTokens[hyperToken].decimals,
            deployer: hyperTokens[hyperToken].tokenOwner,
            chainSupply: type(uint256).max, // Set a dummy chain supply for estimation
            expectedTokenAddress: hyperToken,
            tokenType: hyperTokens[hyperToken].tokenType,
            backingToken: hyperTokens[hyperToken].backingToken,
            tokenId: hyperTokens[hyperToken].tokenId
        });

        // Estimate the fee amount for the deployment 
        // Call the CCHTTP_Peer to estimate the fee
        (feeAmount, ackAmount) = ICCHTTP_Peer(CCHTTP_peer).getFeesForDeployAndMint(
            params
        );
        
        return (feeAmount, ackAmount); 
    }


    function isLastDeployment(
        address _hyperToken,
        uint64 _chainId
    ) internal /*view*/ returns (bool) {
        // Check if the deployment is the last one
        hyperTokenInfo storage info = hyperTokens[_hyperToken];
        if (info.deployments.length == 0) {
            return false;
        }
        //start in 1 bc 0 is for mother chain
        for (uint256 i = 1; i < info.deployments.length; i++) {
            if( info.deployments[i].chainId == _chainId ) {
                emit DebugBytes("isLastDeployment: found deployment for chainId: ", abi.encodePacked(_chainId));
                continue;
            }else{
                //if any chain is still waiting return false
                if( info.deployments[i].waiting ) {
                    emit Debug("isLastDeployment: found a deployment that is still waiting");
                    emit DebugBytes("isLastDeployment: chainId: ", abi.encodePacked(info.deployments[i].chainId));
                    emit DebugBytes("isLastDeployment: hyperToken: ", abi.encodePacked(_hyperToken));
                    emit DebugBytes("isLastDeployment: _chainId: ", abi.encodePacked(_chainId));
                    emit DebugBytes("isLastDeployment: info.deployments[i].chainId: ", abi.encodePacked(info.deployments[i].chainId));
                    emit DebugBytes("isLastDeployment: info.deployments[i].waiting: ", abi.encodePacked(info.deployments[i].waiting));
                    emit DebugBytes("isLastDeployment: info.deployments[i].chainSupply: ", abi.encodePacked(info.deployments[i].chainSupply));
                    return false;
                }
            }
        }
        return true;
    }
    

    function updateSupply(
        address hyperToken,
        int256 deltaSupply,
        address destination,
        address feeToken,
        uint256 feesAmount
    ) external returns (bool) {
        require(msg.sender == hyperToken, "Only the hyperToken can update supply");
        hyperTokenInfo storage info = hyperTokens[hyperToken];
        require(info.hyperToken != address(0), "HyperToken does not exist");

        if (chainId == info.motherChainId) {
            // On Motherchain: update totalSupply 
            if(deltaSupply < 0) {
                require(uint256(-deltaSupply) <= info.totalSupply, "Insufficient total supply for update");
                uint256 absDeltaSupply = uint256(-deltaSupply);
                info.totalSupply -= absDeltaSupply; // Decrease the total supply
            }
            else {
                info.totalSupply += uint256(deltaSupply); // Increase the total supply
            }
            
            // Update the supply on the hyperToken contract
            HyperToken(hyperToken).updateSupply(
                info.totalSupply,
                destination
            ); // Call the updateSupply function on the hyperToken contract
            emit Debug("updateSupply: Motherchain updated supply");
            return true;

        } else {
            // On child chain: send cross-chain request to Motherchain
            CCHTTP_Types.updateSupplyParams memory params = CCHTTP_Types.updateSupplyParams({
                chainId: info.motherChainId,
                feeToken: feeToken,
                feesAmount: feesAmount,
                amount: deltaSupply,
                hyperToken: hyperToken,
                destination: destination
            });
            cashInAndApproveFeesAndACK(
                feeToken,
                feesAmount,
                address(0),
                uint256(0),
                CCHTTP_peer
            );
            bool sent = ICCHTTP_Peer(CCHTTP_peer).updateSupplyRequest(params);
            emit Debug("updateSupply: Sent cross-chain updateSupplyRequest to Motherchain");
            return sent;

        }
    }


    //ICCHTTP_Consumer implementation
    function DeployAndMintReceived(
        uint64 origChain,
        CCHTTP_Types.deploy_and_mint_mssg memory params
    ) external override returns (bool) {
        uint256 gas = gasleft();
        emit DebugBytes("Gas left: ", abi.encodePacked(gas));
        require(msg.sender == CCHTTP_peer, "Not CCHTTP peer");
        // DEployment order received from peer chain
        //will deploy a child hyperToken
        
        emit Debug("DeployAndMintReceived: deploying hyperToken");
        if( params.tokenType == CCHTTP_Types.HyperToken_Types.HyperNative ) {
            // On child chain, we need to deploy the hyperNative
            _deployHyperNative(
                origChain, // The original chain where the hyperNative is deployed
                params.name,
                params.symbol,
                params.decimals,
                params.backingToken,
                params.deployer
            );
            address childHyperNative = peerChainHyperNative[origChain];
            emit Debug("DeployAndMintReceived: hyperNative deployed on child chain");
            registerHyperToken(childHyperNative); // Register the hyper token in the TokenAdminRegistry
            emit Debug("DeployAndMintReceived: hyperNative registered in TokenAdminRegistry");
        }
        else{
            // Create and init the hyperToken instance
            deployHyperToken(
                deployHyperTokenParams({
                    motherChainId: origChain, //mother chain id, is origin chain bc sends order
                    name: params.name,
                    symbol: params.symbol,
                    decimals: params.decimals,
                    backingToken: params.backingToken,
                    tokenId: params.tokenId, 
                    chainSupply: params.chainSupply,
                    tokenOwner: params.deployer,
                    tokenType: params.tokenType
                })
            );
            emit Debug("DeployAndMintReceived: hyperToken deployed on child chain");
        }
        emit Debug("DeployAndMintReceived: hyperToken deployed");
        
        return true;
    }

    function DeployAndMintConfirmed(
        uint64 origChain,
        CCHTTP_Types.deploy_and_mint_mssg memory params
    ) external override returns (bool) {
        emit Debug("DeployAndMintConfirmed called");
        uint256 gas = gasleft();
        emit DebugBytes("Gas left: ", abi.encodePacked(gas));
        address hyperToken = params.expectedTokenAddress;
        require(msg.sender == CCHTTP_peer, "Not CCHTTP peer");
        // Deployment confirmed by peer chain
        //will deploy a child hyperToken
        //mark deployment as done and not waiting
        uint256 chainIdx;
        for (uint256 i = 0; i < hyperTokens[hyperToken].deployments.length; i++) {
            if (hyperTokens[hyperToken].deployments[i].chainId == origChain) {
                emit DebugBytes("DeployAndMintConfirmed: found deployment on chain: ", abi.encodePacked(origChain));
                emit DebugBytes("DeployAndMintConfirmed: chainIdx: ", abi.encodePacked(i));
                chainIdx = i;
                break;
            }
        }
        hyperTokens[hyperToken].deployments[chainIdx].waiting = false;
        if( params.tokenType == CCHTTP_Types.HyperToken_Types.HyperERC20 ||
            params.tokenType == CCHTTP_Types.HyperToken_Types.HyperERC721 ) {
            emit Debug("DeployAndMintConfirmed: hyperToken is ERC20 or ERC721");
            // For ERC20 and ERC721, we need to check if this is the last deployment
            // If this is the last deployment, we can deploy the hyperToken
            if( isLastDeployment( hyperToken, origChain) ) {
                emit Debug("DeployAndMintConfirmed: 3");
                deployHyperToken(
                    deployHyperTokenParams({
                        motherChainId: chainId, //mother chain id, is this chain bc receives confirmation
                        name: params.name,
                        symbol: params.symbol,
                        decimals: params.decimals,
                        backingToken: params.backingToken,
                        tokenId: params.tokenId, // For ERC20, tokenId is not used
                        chainSupply: params.chainSupply,
                        tokenOwner: params.deployer,
                        tokenType: params.tokenType
                    })
                );
            }
        }
        else if( params.tokenType == CCHTTP_Types.HyperToken_Types.HyperNative ) {
            if ( isLastDeployment( hyperToken, origChain) ) {
                //native alreadycreated in deployHyperNative
                registerHyperToken(hyperToken); // Register the hyper token in the TokenAdminRegistry
                emit Debug("DeployAndMintConfirmed: last hyperNative deployment confirmed, registering hyperToken");
            }    
        }
        else {
            revert("Unknown token type");
        }
        return true;
    }



    function estimateUpdateSupplyCost(
        uint64 chain,
        address hyperToken,
        address feeToken // The fee token to be used for the update supply
    ) public /*view*/ returns (uint256 feeAmount) {
        // Estimate the fee amount for the update supply
        // Check if the hyperToken exists
        require(hyperTokens[hyperToken].hyperToken != address(0), "HyperToken does not exist");

        // Prepare the update supply parameters
        CCHTTP_Types.updateSupplyParams memory params = CCHTTP_Types.updateSupplyParams({
            chainId: chain,
            feeToken: feeToken,
            feesAmount: 0, // This will be estimated later
            amount: 0, // The new supply to be set, can be set to 0 for estimation
            hyperToken: hyperToken,
            destination: hyperTokens[hyperToken].tokenOwner // Use the token owner as the destination
        });

        // Call the CCHTTP_Peer to estimate the fee
        feeAmount = ICCHTTP_Peer(CCHTTP_peer).getFeesForUpdateSupply(
            params
        );
        return (feeAmount); // Just return the sum of fees for now
    }

    function UpdateTotalSupplyReceived(
        uint64 origChain,
        CCHTTP_Types.update_supply_mssg memory params
    ) external override returns (bool) {
        require(msg.sender == CCHTTP_peer, "Not CCHTTP peer");
        emit Debug("UpdateTotalSupplyReceived");
        uint256 absAmount = uint256(params.amount < 0 ? -params.amount : params.amount);
        
        uint256 newSupply = hyperTokens[params.hyperToken].totalSupply + absAmount;
        hyperTokens[params.hyperToken].totalSupply = newSupply;
        emit Debug("UpdateTotalSupplyReceived: new total supply calculated");

        // Only the Motherchain updates supply
        if (chainId == hyperTokens[params.hyperToken].motherChainId) {
            HyperToken(params.hyperToken).updateSupply(newSupply, params.destination);
            if(
                hyperTokens[params.hyperToken].tokenType == CCHTTP_Types.HyperToken_Types.HyperERC20 ||
                hyperTokens[params.hyperToken].tokenType == CCHTTP_Types.HyperToken_Types.HyperNative
            ) {
                // If the hyperToken is an ERC20, call releaseBacking amount of backing tokens
                ERC20Backed_hyperToken(params.hyperToken).releaseBacking(
                    uint256(absAmount), // Amount to release
                    params.destination // Destination address
                );
            }
            emit Debug("UpdateTotalSupplyReceived: mother chain update");
        } else {
            // On non-mother chains, do nothing (or emit event for tracking)
            emit Debug("UpdateTotalSupplyReceived: not mother chain, no action");
        }
        emit Debug("UpdateTotalSupplyReceived: done");
        return true;
    }
}
